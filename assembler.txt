import Foundation

enum TokenType {
    case Register
    case LabelDefinition
    case Label
    case ImmediateString
    case ImmediateInteger
    case ImmediateTuple
    case Instruction
    case Directive
    case BadToken
}

struct Token {
    let type: TokenType
    let intValue: Int?
    let stringValue: String?
    let tupleValue: Tuple?
}

struct Tuple {
    let currentState: Int
    let inputCharacter: Int
    let newState: Int
    let outputCharacter: Int
    let direction: Int
}

enum Instruction: Int {
    case halt, clrr, clrx, clrm, clrb, movir, movrr, movrm, movmr, movxr, movar,
    movb, addir, addrr, addmr, addxr, subir, subrr, submr, subxr, mulir,
    mulrr, mulmr, mulxr, divir, divrr, divmr, divxr, jmp, sojz, sojnz, aojz,
    aojnz, cmpir, cmprr, cmpmr, jmpn, jmpz, jmpp, jsr, ret, push, pop,
    stackc, outci, outcr, outcx, outcb, readi, printi, readc, readln, brk,
    movrx, movxx, outs, nop, jmpne
}

let directives: Set<String> = ["string", "integer", "tuple"]

var labels = [String: Int]()


func splitStringByWhiteSpace(expression: String)->[String] {
    return expression.componentsSeparatedByString(" ")
}

func splitStringIntoLines(expression: String)->[String] {
    return expression.componentsSeparatedByString("/n")
}

func readFromTextFile(fileName: String)->String {
    let result = try? String(contentsOfFile: fileName, encoding: NSUTF8StringEncoding)
    return result!
}

func readFromConsole() -> String {
    let BUFSIZE = 1024
    var buf = [CChar](count: BUFSIZE, repeatedValue: CChar(0))
    fgets(&buf, Int32(BUFSIZE), stdin)
    var line: String = String.fromCString(buf)!
    line = line.substringToIndex(line.endIndex.predecessor())
    return line
}
